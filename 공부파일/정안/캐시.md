# 💾 Redis 캐시 전략 정리
### Redis가 캐시로 사용되는 이유
Redis는 디스크 기반 DB보다 훨씬 빠른 인메모리 캐시로 사용되어 초고속 응답 성능을 목적으로 사용한다.

단, 메모리는 디스크보다 용량이 작고 휘발성이므로 어떤 데이터를 얼마나 오래 저장할지 전략이 필요
(persistence도 제공해 원한다면 영속성을 갖도록 할 수 있음)

### 용어 정리

* cache hit : 요청한 데이터가 캐시에 존재할 때
* cache miss : 캐시에 없어서 DB를 조회해야 할 때
* cache warming : 캐시에 미리 db 데이터를 입력하는 것

# 📖 캐시 읽기 전략 (Read Strategies)
### 1. Look Aside (= Cache Aside)
![1](images/1.png)
캐시 먼저 조회 → 없으면 DB에서 조회하여 캐시에 저장

**장점**
* 캐시 장애 시 DB로 우회 가능해 서비스 전체에 영향이 적음(유연함)
  
**단점**
* TTL 관리 필요(데이터 정합성 문제)

### 2. Read Through
![2](images/2.png)
캐시만을 조회(캐시에 없으면 DB에서 캐시 업데이트)

**장점**
* DB접근을 최소화하여 read작업에 소모되는 자원 최소화
  
**단점**
* 캐시에 장애 발생 시 → 전체 장애 가능 → Replication / Cluster 구성 필수
* TTL 관리 필요(데이터 정합성 문제)
  
# 📝 캐시 쓰기 전략 (Write Strategies)
### 1. Write Back (= Write Behind)
![3](images/3.png)
쓰기 요청을 캐시에 먼저 저장하고
일정 주기마다 캐시가 DB로 한번에 반영

**장점**
* 쿼리 회수 비용 및 DB 부하 감소 - Write가 매우 많은 서비스에 적합 

**단점**
* 캐시에 장애가 발생하면 미반영 데이터 유실 위험
* 불필요한 데이터도 캐시에 계속 저장됨

### 2. Write Through
![4](images/4.png)
캐시에 먼저 쓰고, 그 즉시 DB에도 저장

**장점**
* 항상 최신 데이터를 유지해 캐시와 DB 정합성이 매우 높음 - 데이터 유실에 민감한 작업에 적합

**단점**
* 요청마다 2번의 write작업으로 인한 성능 저하
* 불필요한 데이터도 캐시에 계속 저장됨

### 3. Write Around
![5](images/5.png)
모든 쓰기를 DB에만 저장

**장점**
* 모든 write를 캐시에 쓰지 않아 캐시 공간을 자주 읽히는 핵심 데이터만 사용

**단점**
* 수정 시 캐시 반영이 안 되어 정합성 이슈 발생 가능 - 한번만 쓰이고 거의 읽히지 않는 데이터에 적합


# ⚠️ 캐시 사용 시 고려해야 할 공통 한계점

캐시는 성능을 크게 향상시키지만, 단점들에서 살펴본 문제들로 근본적인 트레이드오프가 항상 존재한다.<br>
따라서 Read/Write 전략을 선택할 때 반드시 함께 고려해야 한다.

1. 성능 향상 vs. 일관성(consistency) 문제

캐시된 데이터는 실제 DB보다 오래된 값일 수 있어, **항상 최신 데이터**라고 보장할 수 없음.<br>
따라서 TTL, 캐시 무효화(invalidation), 동기화 전략이 필수적으로 따라옴.<br>
Write Around / Look Aside 환경에서는 특히 일관성 관리가 중요함.

2. 속도 향상 vs. 운영 오버헤드 증가

캐시를 도입하면 메모리·디스크·네트워크 리소스가 추가로 필요하며 시스템 복잡성이 증가함.<br>
Redis 같은 분산 캐시는 네트워크 Round Trip 비용이 새로 발생.<br>
캐시 관리(TTL, Warm-up, Stampede 방지, 장애 복구 등)도 운영팀의 부담을 늘림.

3. 저장 용량 관리 문제

캐시 공간은 제한적이므로, 오래된 데이터를 삭제하는 정책(LRU, LFU 등)이 필요함.<br>
캐시를 과도하게 사용하거나 데이터가 너무 많이 쌓이면 **메모리 부족**(Out of Memory) 상황이 발생할 수 있음.<br>
따라서 어떤 데이터를 캐싱할지(주로 자주 읽히고 잘 변하지 않는 데이터) 전략적으로 선택해야 함.

**정리**<br>
redis를 도입하거나 ttl 값을 결정할 때는 반드시 이러한 여러 트레이드오프 관점을 함께 고민해야한다.<br>
성능을 위해 redis를 도입하는 대신, 그만큼 운영 오버헤드가 증가할것이며<br>
성능을 위해 ttl을 너무 길게 잡으면, 일관성과 저장 용량에 문제가 생길 것이다.<br>
결국, 캐시는 성능 향상과 운영 부담 사이에서 균형을 잡는 의사결정이 필요하다.  
  
# 🔀 캐시 읽기 + 쓰기 전략 조합

1. Look Aside + Write Around

2. Read Through + Write Around
   
3. Read Through + Write Through


#  📦 캐시 저장 방식

* 캐시는 자주 읽히고 잘 변하지 않는 데이터를 저장해야 효과적
→ Cache Hit Ratio 향상

* Redis는 휘발성이며 데이터 유실 가능
→ 민감한 데이터 저장 지양

* 파레토 법칙(8:2 법칙)
20%의 데이터만으로 80%의 서비스를 커버할 수 있다.

# ⏳ 캐시 제거(만료) 방식

캐시는 일반적으로 영구 저장소(DB)의 복사본으로 동작하므로 만료(TTL) 정책이 반드시 필요하다.

**TTL이 너무 짧으면**
> 캐시 이점이 거의 없음<br>
> Cache Stampede 발생 가능 (많은 요청이 동시에 캐시 미스 → DB에 몰림 → 성능 저하 악순환)<br>
> Cache Stampede 해결법
>> Stampede 방지 기법<br>
>> * mutex-lock (단일 요청만 DB 접근 허용)<br>
>> * TTL + 랜덤값 혼합<br>
>> * Soft TTL (2개의 TTL 이용)

**TTL이 너무 길면**
> 메모리 부족<br>
> 오래된 데이터가 계속 사용될 가능성

# 🔒 캐시 공유·동시성 지침

캐시는 여러 애플리케이션의 인스턴스에서 공유되며
어느 한 애플리케이션 인스턴스가 수정할 때, 수정 중 충돌이 일어나면 안 됨 → race condition 위험

Redis는 **싱글 스레드** 기반이라
→ 명령이 순차적으로 처리되어 기본적인 race condition이 없음
> 대규모 트래픽에서는 *Redis Cluster*로 운영(slot 범위로 각 redis가 데이터 나눠 가짐)

# ♻️ 캐시 가용성 지침

캐시는 빠른 응답을 위해 존재하는 컴포넌트

즉, 캐시 장애로 인해 전체 서비스가 중단되면 안 됨
→ 보통 캐시 장애 = 성능 저하, 서비스 자체는 DB로 우회해 운영 가능해야함

# 🧩 Redis 특성과 구조

1. Redis는 다양한 Collection Type을 제공함
2. 싱글스레드 기반
3. RDB/AOF 기반 persistence 지원 → 재시작 시 데이터 복구 가능

# redis 장애 해결 방법
redis는 기본적으로 싱글 인스턴트지만 Master-Replica구조로 구성을 바꾸어 
Master노드가 다운되면 이를 복제하던 Replica가 Master로 승격하고,<br>
이후 Replica를 하나 더 생성하여 기존 형태를 유지합니다.

이런 예시로 실무에서 많이 발생하는 Hot Key 문제가 있습니다.

✔ Hot Key란?
> 특정 key가 너무 많이 요청되면<br>
> 해당 key가 저장된 Redis Master 노드만 과부하됨 → 장애 발생

// 만약 redis 서버가 다운되는 등 마스터, 레플리카가 모두 장애가 발생하면 재부팅 + cache warming(원하면 persistence 파일 이용) 
      → 로컬 캐시를 두어 일부 기능은 유지하게 하는 경우도 많음
